;;;; Ex 1.15

;;; Given the following procedures to compute the sine of an angle
(define (cube x) (* x x x))

(define (p x) (- (* 3 x) (* 4 (cube x))))

(define (sine angle)
  (if (not (> (abs angle) 0.1))
      angle
      (p (sine (/ angle 3.0)))))

;;; a. How many times is the procedue `p` applied when (sine 12.15) is
;;;    evaluated?
;;;
;;; `p` will be evaluated until the angle is <= 0.1
;;;
;;; Let's write out the behavior for (sine 12.15)
(sine 12.15)
(p (sine 4.05))
(p (p (sine 1.35)))
(p (p (p (sine 0.45))))
(p (p (p (p (sine 0.15)))))
(p (p (p (p (p (sine 0.05))))))
(p (p (p (p (p 0.05)))))
(p (p (p (p 0.1495))))
(p (p (p 0.43513455)))
(p (p 0.9758465533))
(p -0.7895631145)
-0.39980345726
;;;
;;; So, for the specific example of (sine 12.5), `p` is called 5 times

;;; b. What is the order of growth in space and number of steps (as a function
;;;    of `a`) used by the process generated by the `sine` procedure when 
;;;    (sine a) is evaluated?
;;;
;;; So, let's take our generic example and generalize it to any input.
;;;
;;; For an input `a`, we know that we will continue to divide it by 3 until
;;;   the value is <= 0.1, and each time we divide by 3, we are making a call
;;;   to `sine` in an expanding behavior, and a chained call to `p` in a 
;;;   contracting behavior.
;;;
;;; So, for an input `a`, we need to determine the number of times `k` it can 
;;;   be divided by 3 before being <= 0.1, since this will be proportional to
;;;   the number of steps.
;;; This can be represented by:
;;;     a/(3^k) <= 0.1
;;; Then we minimize the above for `k`.
;;;
;;;     a/(3^k)       <= 0.1
;;;     (10a)/(3^k)   <= 1
;;;     10a           <= 3^k
;;;     log_{3}10a    <= log_{3}3^k   ; log base 3
;;;     log_{3}10a    <= k
;;;     log10a / log3 <= k
;;;
;;; This will give an exact decimal value for `k` such that a/(3^k) <= 0.1.
;;; However, we need `k` to be an integer.  Since `k` must be equal to or
;;;   greater than this decimal value, the closest value will be the integer
;;;   calculated as the ceiling of the decimal value.
;;; Thus, the minimal integer value of `k` is as follows.
;;;     ceil(log10a / log3) = k
;;;
;;; We also can see that we will make the initial call to `sine`, and then
;;;   for each `k`, we will make a call to `sine`, and a deferred call to `p`.
;;; So, the `R` function is:
;;;     R_steps((sine a)) = 2k + 1, where k is the interger found above.
;;;
;;; So, for an input `a`, the number of steps is proportional to a log of `a`,
;;;   so the order of growth of the number of steps for a sufficient large 
;;;   input `a` is:
;;;     R_steps((sine a)) = theta(log a)
;;;
;;; For the amount of space used, this is a recursive process, and the length
;;;   of the chain of deferred operations grows logarithmically with `a`, as
;;;   shown above.
;;;
;;; Therefore, for an input `a`, the order of growth in space used is:
;;;     R_space((sine a)) = theta(log a)


