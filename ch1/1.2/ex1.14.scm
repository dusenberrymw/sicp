;;;; Ex 1.14

;;; Goal here is to determine the orders of growth of steps and space used by
;;;   the process generated by the `count-change` procedure
;;;

;;; Let's start with the code itself:
(define (count-change amount)
  (cc amount 5))

(define (cc amount kinds-of-coins)
  (cond ((= amount 0) 1)
        ((or (< amount 0) (= kinds-of-coins 0)) 0)
        (else (+ (cc amount (- kinds-of-coins 1))
                 (cc (- amount (first-denomination kinds-of-coins))
                     kinds-of-coins)))))

(define (first-denomination kinds-of-coins)
  (cond ((= kinds-of-coins 1) 1)
        ((= kinds-of-coins 2) 5)
        ((= kinds-of-coins 3) 10)
        ((= kinds-of-coins 4) 25)
        ((= kinds-of-coins 5) 50)))


;;; Now we want to draw the tree visualizing the behavior of the process for
;;;   counting change for 11 cents.
;;;
;;; Let's start with the space growth:
;;;
;;; The tree shows that the longest segment is using pennies for 11 cents,
;;;   which is proportional to depth to n.
;;;
;;; Since the longest segment is going to be length n, and we compute the
;;;   full depth of a branch before moving on to the next branch, the
;;;   size complexity will be R1(n) = theta(n).
;;;

;;; Now let's determine the order of growth of the number of steps.
;;;
;;; Let's start with the case of the kind of coin being of kind 0:
;;;     (count-change n 0)
;;; In this case, we immediately return the value `0`, so the operation only
;;;   involves one step.
;;; Thus,
;;;     R((count-change n 0)) = 1 = theta(1)
;;;   because one step is constant in the number of steps.
;;;
;;;
;;; Now, let's look at the case of the coin being of kind 1:
;;;     (count-change n 1)
;;; In this case, we have the original step, and then two other branches are
;;;   spawned off:
;;;     (count-change n 0)
;;;     (count-change n-1 1)
;;; The first of the two operations is constant time, and thus is theta(1).
;;; The second of the two operations in turn spawns another two similar
;;;   branches.
;;; For amount `n`, we spawn 2 nodes in a chain fashion `n` times from the
;;;   original node.
;;; Therefore,
;;;     R((count n 1)) = 2n + 1 = theta(n)
;;;     
;;;
;;; Now, let's look at the case of the coin being of kind 2:
;;;     (count-change n 2)
;;; In this case, we have the original step, and then two other branches are
;;;   spawned off:
;;;     (count-change n 1)
;;;     (count-change n-5 2)
;;; From above, we know that the first branch will have and order of growth
;;;   theta(n) for the numnber of steps.
;;; The second branch will in turn spawn two more branches, one of which will
;;;   again be a kind 1 branch with growth theta(n).
;;; So, from this we can see that every call to (count-change k 2) results in
;;;   in a theta(k) operation.
;;; Therefore, we need to decide how many calls to (count-change k 2) will
;;;   occur for (count-change n 2).
;;; The recursive calls of (count-change n-5 2) continue to occur until the 
;;;   amount is <= 0.
;;; From this, we can deduce that there will be floor(n/5) calls that will
;;;   spawn a (count-change n 1) call.
;;; Thus, there will be ~n/5 calls that are O(n), and therefore:
;;;     R((count n 2)) ~= (n/5) * (2n + 1) = (2/5)n^2 + n/5 = theta(n^2)
;;;
;;;
;;; Now, the same pattern will apply for the rest of the coin types:
;;;
;;; R((count n 3)) ~= (n/10) * R((count n 2)) = n^3 + n^2 + ... = theta(n^3)
;;; R((count n 4)) ~= (n/25) * R((count n 3)) = theta(n^4)
;;; R((count n 5)) ~= (n/50) * R((count n 4)) = theta(n^5)

;;; So, generically, for coin type k, the order of growth of the number of
;;;   steps is:
;;;     R((count n k)) = theta(n^k)
;;;


